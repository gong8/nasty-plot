"use client"

import { useState, useCallback, useRef } from "react"
import type { ChatMessageMetadata } from "@nasty-plot/core"
import { fetchApiData } from "@/lib/api-client"
import type { UIChatMessage, ToolCallState, ActionNotification, PlanStep } from "./types"

function isVisibleMessage(m: { role: string; metadata?: ChatMessageMetadata }): boolean {
  return m.role !== "system" && !(m.role === "user" && m.metadata?.autoGenerated)
}

export function useChatMessages(initialSessionId?: string) {
  const [messages, setMessages] = useState<UIChatMessage[]>([])
  const [isStreaming, setIsStreaming] = useState(false)
  const [toolCalls, setToolCalls] = useState<Map<string, ToolCallState>>(new Map())
  const [actionNotifications, setActionNotifications] = useState<ActionNotification[]>([])
  const [planSteps, setPlanSteps] = useState<PlanStep[]>([])
  const [currentSessionId, setCurrentSessionId] = useState(initialSessionId)
  const [queuedMessage, setQueuedMessage] = useState<string | null>(null)
  const currentSessionIdRef = useRef(initialSessionId)
  const queuedMessageRef = useRef<string | null>(null)

  const loadSession = useCallback(async (id: string) => {
    try {
      const session = await fetchApiData<{
        messages?: { id?: number; role: string; content: string; metadata?: ChatMessageMetadata }[]
      }>(`/api/chat/sessions/${id}`)
      if (session?.messages) {
        setMessages(
          session.messages.filter(isVisibleMessage).map((m, i) => ({
            id: m.id?.toString() ?? `loaded-${i}`,
            role: m.role as "user" | "assistant",
            content: m.content,
            metadata: m.metadata,
          })),
        )
      }
    } catch {
      // Session load is optional
    }
  }, [])

  const beginStream = useCallback((placeholderMessage: UIChatMessage) => {
    setIsStreaming(true)
    setToolCalls(new Map())
    setActionNotifications([])
    setPlanSteps([])
    setMessages((prev) => [...prev, placeholderMessage])
  }, [])

  const clearQueuedMessage = useCallback(() => {
    setQueuedMessage(null)
    queuedMessageRef.current = null
  }, [])

  const updateQueuedMessage = useCallback((text: string) => {
    setQueuedMessage(text)
    queuedMessageRef.current = text
  }, [])

  const resetForSession = useCallback(
    (id: string | null) => {
      // Skip reset if the hook already owns this session (e.g., after streaming
      // created it) -- avoids clearing messages that were built during streaming
      if (id && id === currentSessionIdRef.current) return

      setMessages([])
      setToolCalls(new Map())
      setActionNotifications([])
      setPlanSteps([])
      setQueuedMessage(null)
      queuedMessageRef.current = null
      setCurrentSessionId(id ?? undefined)
      currentSessionIdRef.current = id ?? undefined
      if (id) {
        loadSession(id)
      }
    },
    [loadSession],
  )

  return {
    messages,
    setMessages,
    isStreaming,
    setIsStreaming,
    toolCalls,
    setToolCalls,
    actionNotifications,
    setActionNotifications,
    planSteps,
    setPlanSteps,
    currentSessionId,
    setCurrentSessionId,
    currentSessionIdRef,
    queuedMessage,
    setQueuedMessage,
    queuedMessageRef,
    loadSession,
    beginStream,
    clearQueuedMessage,
    updateQueuedMessage,
    resetForSession,
  }
}
