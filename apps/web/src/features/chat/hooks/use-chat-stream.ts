"use client"

import { useState, useCallback, useRef, useEffect } from "react"
import { usePageContext } from "@/features/chat/context/page-context-provider"
import { useChatSidebar } from "@/features/chat/context/chat-provider"
import { useQueryClient } from "@tanstack/react-query"
import type { ChatMessageMetadata, AutoAnalyzeDepth } from "@nasty-plot/core"
import { fetchApiData } from "@/lib/api-client"

export interface UIChatMessage {
  id: string
  role: "user" | "assistant"
  content: string
  metadata?: ChatMessageMetadata
}

export interface ToolCallState {
  name: string
  label: string
  input: Record<string, unknown>
  status: "executing" | "complete" | "error"
  error?: string
}

export interface ActionNotification {
  name: string
  label: string
  input: Record<string, unknown>
}

export interface PlanStep {
  text: string
  status: "pending" | "active" | "complete" | "skipped"
}

export interface ChatStreamOptions {
  onActionNotify?: (notification: ActionNotification) => void
}

const SSE_DATA_PREFIX = "data: "

function isVisibleMessage(m: { role: string; metadata?: ChatMessageMetadata }): boolean {
  return m.role !== "system" && !(m.role === "user" && m.metadata?.autoGenerated)
}

type MessagesSetter = React.Dispatch<React.SetStateAction<UIChatMessage[]>>
type ToolCallsSetter = React.Dispatch<React.SetStateAction<Map<string, ToolCallState>>>

interface SSEHandlers {
  setMessages: MessagesSetter
  setToolCalls: ToolCallsSetter
  setPlanSteps: React.Dispatch<React.SetStateAction<PlanStep[]>>
  setActionNotifications: React.Dispatch<React.SetStateAction<ActionNotification[]>>
  queryClient: ReturnType<typeof useQueryClient>
  optionsRef: React.RefObject<ChatStreamOptions | undefined>
}

function appendToLastAssistant(
  setMessages: MessagesSetter,
  updater: (last: UIChatMessage) => Partial<UIChatMessage>,
) {
  setMessages((prev) => {
    const last = prev[prev.length - 1]
    if (!last || last.role !== "assistant") return prev
    const updated = [...prev]
    updated[updated.length - 1] = { ...last, ...updater(last) }
    return updated
  })
}

function updateToolCallStatus(
  setToolCalls: ToolCallsSetter,
  name: string,
  update: Partial<ToolCallState>,
) {
  setToolCalls((prev) => {
    const existing = prev.get(name)
    if (!existing) return prev
    const next = new Map(prev)
    next.set(name, { ...existing, ...update })
    return next
  })
}

function handleSSEEvent(parsed: Record<string, unknown>, handlers: SSEHandlers) {
  const {
    setMessages,
    setToolCalls,
    setPlanSteps,
    setActionNotifications,
    queryClient,
    optionsRef,
  } = handlers

  switch (parsed.type) {
    case "content":
      appendToLastAssistant(setMessages, (last) => ({
        content: last.content + (parsed.content as string),
      }))
      break

    case "tool_start":
      setToolCalls((prev) => {
        const next = new Map(prev)
        next.set(parsed.name as string, {
          name: parsed.name as string,
          label: parsed.label as string,
          input: parsed.input as Record<string, unknown>,
          status: "executing",
        })
        return next
      })
      break

    case "tool_end":
      updateToolCallStatus(setToolCalls, parsed.name as string, { status: "complete" })
      break

    case "tool_error":
      updateToolCallStatus(setToolCalls, parsed.name as string, {
        status: "error",
        error: parsed.error as string,
      })
      break

    case "action_notify": {
      const notification: ActionNotification = {
        name: parsed.name as string,
        label: parsed.label as string,
        input: parsed.input as Record<string, unknown>,
      }
      setActionNotifications((prev) => [...prev, notification])
      queryClient.invalidateQueries({ queryKey: ["team"] })
      optionsRef.current?.onActionNotify?.(notification)
      break
    }

    case "plan_start":
      setPlanSteps(
        (parsed.steps as { text: string }[]).map((s) => ({
          text: s.text,
          status: "pending" as const,
        })),
      )
      break

    case "plan_step_update":
      setPlanSteps((prev) => {
        const idx = parsed.stepIndex as number
        if (idx < 0 || idx >= prev.length) return prev
        const updated = [...prev]
        updated[idx] = { ...updated[idx], status: parsed.status as PlanStep["status"] }
        return updated
      })
      break

    case "session_meta":
      if (parsed.title) {
        queryClient.invalidateQueries({ queryKey: ["chat-sessions"] })
      }
      break

    case "error":
      appendToLastAssistant(setMessages, () => ({
        content: `Error: ${parsed.error}`,
      }))
      break

    default:
      // Legacy format support
      if (!parsed.type && parsed.content) {
        appendToLastAssistant(setMessages, (last) => ({
          content: last.content + (parsed.content as string),
        }))
      }
      if (!parsed.type && parsed.toolCall) {
        const tc = parsed.toolCall as { name: string; status: string }
        if (tc.status === "executing") {
          setToolCalls((prev) => {
            const next = new Map(prev)
            next.set(tc.name, {
              name: tc.name,
              label: `Running ${tc.name}...`,
              input: {},
              status: "executing",
            })
            return next
          })
        } else {
          updateToolCallStatus(setToolCalls, tc.name, { status: "complete" })
        }
      }
      break
  }
}

async function readSSEStream(body: ReadableStream<Uint8Array>, handlers: SSEHandlers) {
  const reader = body.getReader()
  const decoder = new TextDecoder()
  let buffer = ""

  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    buffer += decoder.decode(value, { stream: true })
    const lines = buffer.split("\n")
    buffer = lines.pop() ?? ""

    for (const line of lines) {
      if (!line.startsWith(SSE_DATA_PREFIX)) continue
      try {
        handleSSEEvent(JSON.parse(line.slice(SSE_DATA_PREFIX.length)), handlers)
      } catch {
        // Skip non-JSON
      }
    }
  }
}

export function useChatStream(sessionId?: string, options?: ChatStreamOptions) {
  const [messages, setMessages] = useState<UIChatMessage[]>([])
  const [isStreaming, setIsStreaming] = useState(false)
  const [toolCalls, setToolCalls] = useState<Map<string, ToolCallState>>(new Map())
  const [actionNotifications, setActionNotifications] = useState<ActionNotification[]>([])
  const [planSteps, setPlanSteps] = useState<PlanStep[]>([])
  const [currentSessionId, setCurrentSessionId] = useState(sessionId)
  const currentSessionIdRef = useRef(sessionId)
  const abortRef = useRef<AbortController | null>(null)
  const deferredSessionIdRef = useRef<string | null>(null)
  const pageContext = usePageContext()
  const { switchSession, pendingContext, clearPendingContext, registerStreamControl } =
    useChatSidebar()
  const queryClient = useQueryClient()

  // Keep options ref fresh so memoized sendMessage always sees latest callback
  const optionsRef = useRef(options)
  useEffect(() => {
    optionsRef.current = options
  }, [options])

  const sseHandlers: SSEHandlers = {
    setMessages,
    setToolCalls,
    setPlanSteps,
    setActionNotifications,
    queryClient,
    optionsRef,
  }

  function captureNewSessionId(res: Response) {
    const newSessionId = res.headers.get("X-Session-Id")
    if (newSessionId && !currentSessionId) {
      setCurrentSessionId(newSessionId)
      currentSessionIdRef.current = newSessionId
      deferredSessionIdRef.current = newSessionId
      if (pendingContext) clearPendingContext()
    }
  }

  function finalizeStream() {
    setIsStreaming(false)
    abortRef.current = null
    if (deferredSessionIdRef.current) {
      switchSession(deferredSessionIdRef.current)
      deferredSessionIdRef.current = null
    }
    queryClient.invalidateQueries({ queryKey: ["chat-sessions"] })
  }

  function buildContextPayload() {
    const isNewSession = !currentSessionId
    return isNewSession && pendingContext
      ? { contextMode: pendingContext.contextMode, contextData: pendingContext.contextData }
      : {}
  }

  function buildRequestBody(message: string) {
    return {
      sessionId: currentSessionId,
      message,
      teamId: pageContext.teamId,
      formatId: pageContext.formatId,
      context: {
        pageType: pageContext.pageType,
        contextSummary: pageContext.contextSummary,
        teamId: pageContext.teamId,
        pokemonId: pageContext.pokemonId,
        formatId: pageContext.formatId,
      },
      ...buildContextPayload(),
    }
  }

  function beginStream(placeholderMessage: UIChatMessage) {
    setIsStreaming(true)
    setToolCalls(new Map())
    setActionNotifications([])
    setPlanSteps([])
    setMessages((prev) => [...prev, placeholderMessage])
  }

  async function executeStream(
    requestBody: Record<string, unknown>,
    onAbort?: string,
    fallbackError = "Sorry, I encountered an error. Please try again.",
  ) {
    const controller = new AbortController()
    abortRef.current = controller

    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
        signal: controller.signal,
      })

      captureNewSessionId(res)
      if (!res.ok || !res.body) throw new Error("Failed to get response")
      await readSSEStream(res.body, sseHandlers)
    } catch (error) {
      if ((error as Error).name === "AbortError") {
        if (onAbort) {
          appendToLastAssistant(setMessages, (last) => ({
            content: last.content || onAbort,
          }))
        }
        return
      }
      appendToLastAssistant(setMessages, (last) => ({
        content: last.content || fallbackError,
      }))
    } finally {
      finalizeStream()
    }
  }

  // Load existing session messages
  const loadSession = useCallback(async (id: string) => {
    try {
      const session = await fetchApiData<{
        messages?: { id?: number; role: string; content: string; metadata?: ChatMessageMetadata }[]
      }>(`/api/chat/sessions/${id}`)
      if (session?.messages) {
        setMessages(
          session.messages.filter(isVisibleMessage).map((m, i) => ({
            id: m.id?.toString() ?? `loaded-${i}`,
            role: m.role as "user" | "assistant",
            content: m.content,
            metadata: m.metadata,
          })),
        )
      }
    } catch {
      // Session load is optional
    }
  }, [])

  const sendMessage = useCallback(
    async (
      text: string,
      regenerate = false,
      extraContext?: { guidedBuilder: Record<string, unknown> },
    ) => {
      const trimmed = text.trim()
      if (!trimmed || isStreaming) return

      if (!regenerate) {
        setMessages((prev) => [
          ...prev,
          { id: `user-${Date.now()}`, role: "user" as const, content: trimmed },
        ])
      }

      beginStream({ id: `assistant-${Date.now()}`, role: "assistant", content: "" })

      const requestBody = buildRequestBody(trimmed)
      const context = extraContext?.guidedBuilder
        ? { ...requestBody.context, guidedBuilder: extraContext.guidedBuilder }
        : requestBody.context
      await executeStream({ ...requestBody, context, regenerate })
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      isStreaming,
      currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  const sendAutoAnalyze = useCallback(
    async (prompt: string, turn: number, depth: AutoAnalyzeDepth) => {
      if (isStreaming) return

      beginStream({
        id: `auto-${turn}-${Date.now()}`,
        role: "assistant",
        content: "",
        metadata: { autoGenerated: true, turn, depth },
      })

      await executeStream(
        {
          ...buildRequestBody(prompt),
          autoAnalyzeDepth: depth,
          metadata: { autoGenerated: true, turn, depth },
        },
        "You chose your move -- moving on!",
        "Analysis failed. Will retry next turn.",
      )
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      isStreaming,
      currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  // Register stream controls with ChatProvider
  useEffect(() => {
    registerStreamControl({
      sendAutoAnalyze,
      stopGeneration: () => abortRef.current?.abort(),
      isStreaming,
    })
  }, [registerStreamControl, sendAutoAnalyze, isStreaming])

  const stopGeneration = useCallback(() => {
    abortRef.current?.abort()
  }, [])

  const retryLast = useCallback(() => {
    const lastUserMessage = messages.findLast((m) => m.role === "user")
    if (!lastUserMessage) return
    setMessages((prev) => {
      const idx = prev.findLastIndex((m) => m.role === "assistant")
      return idx >= 0 ? [...prev.slice(0, idx), ...prev.slice(idx + 1)] : prev
    })
    sendMessage(lastUserMessage.content, true)
  }, [messages, sendMessage])

  const resetForSession = useCallback(
    (id: string | null) => {
      // Skip reset if the hook already owns this session (e.g., after streaming
      // created it) â€” avoids clearing messages that were built during streaming
      if (id && id === currentSessionIdRef.current) return

      setMessages([])
      setToolCalls(new Map())
      setActionNotifications([])
      setPlanSteps([])
      setCurrentSessionId(id ?? undefined)
      currentSessionIdRef.current = id ?? undefined
      if (id) {
        loadSession(id)
      }
    },
    [loadSession],
  )

  return {
    messages,
    isStreaming,
    toolCalls,
    actionNotifications,
    planSteps,
    currentSessionId,
    sendMessage,
    sendAutoAnalyze,
    stopGeneration,
    retryLast,
    resetForSession,
  }
}
