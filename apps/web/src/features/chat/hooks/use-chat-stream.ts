"use client"

import { useState, useCallback, useRef, useEffect } from "react"
import { usePageContext } from "@/features/chat/context/page-context-provider"
import { useChatSidebar } from "@/features/chat/context/chat-provider"
import { useQueryClient } from "@tanstack/react-query"
import type { ChatMessageMetadata, AutoAnalyzeDepth } from "@nasty-plot/core"

export interface ChatMessage {
  id: string
  role: "user" | "assistant"
  content: string
  metadata?: ChatMessageMetadata
}

export interface ToolCallState {
  name: string
  label: string
  input: Record<string, unknown>
  status: "executing" | "complete" | "error"
  error?: string
}

export interface ActionNotification {
  name: string
  label: string
  input: Record<string, unknown>
}

export interface PlanStep {
  text: string
  status: "pending" | "active" | "complete" | "skipped"
}

export interface ChatStreamOptions {
  onActionNotify?: (notification: ActionNotification) => void
}

export function useChatStream(sessionId?: string, options?: ChatStreamOptions) {
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [isStreaming, setIsStreaming] = useState(false)
  const [toolCalls, setToolCalls] = useState<Map<string, ToolCallState>>(new Map())
  const [actionNotifications, setActionNotifications] = useState<ActionNotification[]>([])
  const [planSteps, setPlanSteps] = useState<PlanStep[]>([])
  const [currentSessionId, setCurrentSessionId] = useState(sessionId)
  const currentSessionIdRef = useRef(sessionId)
  const abortRef = useRef<AbortController | null>(null)
  const deferredSessionIdRef = useRef<string | null>(null)
  const pageContext = usePageContext()
  const { switchSession, pendingContext, clearPendingContext, registerStreamControl } =
    useChatSidebar()
  const queryClient = useQueryClient()

  // Keep options ref fresh so memoized sendMessage always sees latest callback
  const optionsRef = useRef(options)
  useEffect(() => {
    optionsRef.current = options
  }, [options])

  // Load existing session messages
  const loadSession = useCallback(async (id: string) => {
    try {
      const res = await fetch(`/api/chat/sessions/${id}`)
      if (!res.ok) return
      const data = await res.json()
      if (data.data?.messages) {
        setMessages(
          data.data.messages
            .filter((m: { role: string; metadata?: ChatMessageMetadata }) => {
              if (m.role === "system") return false
              // Hide auto-generated user messages (the prompts sent by useAutoAnalyze)
              if (m.role === "user" && m.metadata?.autoGenerated) return false
              return true
            })
            .map(
              (
                m: { id?: number; role: string; content: string; metadata?: ChatMessageMetadata },
                i: number,
              ) => ({
                id: m.id?.toString() ?? `loaded-${i}`,
                role: m.role as "user" | "assistant",
                content: m.content,
                metadata: m.metadata,
              }),
            ),
        )
      }
    } catch {
      // Session load is optional
    }
  }, [])

  const sendMessage = useCallback(
    async (
      text: string,
      regenerate = false,
      extraContext?: { guidedBuilder: Record<string, unknown> },
    ) => {
      const trimmed = text.trim()
      if (!trimmed || isStreaming) return

      if (!regenerate) {
        const userMsg: ChatMessage = {
          id: `user-${Date.now()}`,
          role: "user",
          content: trimmed,
        }
        setMessages((prev) => [...prev, userMsg])
      }

      setIsStreaming(true)
      setToolCalls(new Map())
      setActionNotifications([])
      setPlanSteps([])

      const assistantMsg: ChatMessage = {
        id: `assistant-${Date.now()}`,
        role: "assistant",
        content: "",
      }
      setMessages((prev) => [...prev, assistantMsg])

      const controller = new AbortController()
      abortRef.current = controller

      try {
        // Include context mode for new sessions with pending context
        const isNewSession = !currentSessionId
        const contextPayload =
          isNewSession && pendingContext
            ? {
                contextMode: pendingContext.contextMode,
                contextData: pendingContext.contextData,
              }
            : {}

        const res = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: trimmed,
            teamId: pageContext.teamId,
            formatId: pageContext.formatId,
            context: {
              pageType: pageContext.pageType,
              contextSummary: pageContext.contextSummary,
              teamId: pageContext.teamId,
              pokemonId: pageContext.pokemonId,
              formatId: pageContext.formatId,
              ...(extraContext?.guidedBuilder ? { guidedBuilder: extraContext.guidedBuilder } : {}),
            },
            ...contextPayload,
            regenerate,
          }),
          signal: controller.signal,
        })

        // Capture session ID from response — defer switchSession until after
        // streaming completes to prevent ChatPanel's session-change effect from
        // resetting messages mid-stream
        const newSessionId = res.headers.get("X-Session-Id")
        if (newSessionId && !currentSessionId) {
          setCurrentSessionId(newSessionId)
          currentSessionIdRef.current = newSessionId
          deferredSessionIdRef.current = newSessionId
          // Clear pending context after session is created
          if (pendingContext) clearPendingContext()
        }

        if (!res.ok || !res.body) {
          throw new Error("Failed to get response")
        }

        const reader = res.body.getReader()
        const decoder = new TextDecoder()
        let buffer = ""

        while (true) {
          const { done, value } = await reader.read()
          if (done) break

          buffer += decoder.decode(value, { stream: true })
          const lines = buffer.split("\n")
          buffer = lines.pop() ?? ""

          for (const line of lines) {
            if (!line.startsWith("data: ")) continue
            const data = line.slice(6)

            try {
              const parsed = JSON.parse(data)

              // New typed SSE event protocol
              if (parsed.type === "content") {
                setMessages((prev) => {
                  const updated = [...prev]
                  const last = updated[updated.length - 1]
                  if (last && last.role === "assistant") {
                    updated[updated.length - 1] = {
                      ...last,
                      content: last.content + parsed.content,
                    }
                  }
                  return updated
                })
              }

              if (parsed.type === "tool_start") {
                setToolCalls((prev) => {
                  const next = new Map(prev)
                  next.set(parsed.name, {
                    name: parsed.name,
                    label: parsed.label,
                    input: parsed.input,
                    status: "executing",
                  })
                  return next
                })
              }

              if (parsed.type === "tool_end") {
                setToolCalls((prev) => {
                  const next = new Map(prev)
                  const existing = next.get(parsed.name)
                  if (existing) {
                    next.set(parsed.name, { ...existing, status: "complete" })
                  }
                  return next
                })
              }

              if (parsed.type === "tool_error") {
                setToolCalls((prev) => {
                  const next = new Map(prev)
                  const existing = next.get(parsed.name)
                  if (existing) {
                    next.set(parsed.name, {
                      ...existing,
                      status: "error",
                      error: parsed.error,
                    })
                  }
                  return next
                })
              }

              if (parsed.type === "action_notify") {
                const notification = {
                  name: parsed.name,
                  label: parsed.label,
                  input: parsed.input,
                }
                setActionNotifications((prev) => [...prev, notification])
                // Invalidate team data queries after write actions
                queryClient.invalidateQueries({ queryKey: ["team"] })
                // Notify external listeners (e.g. guided builder)
                optionsRef.current?.onActionNotify?.(notification)
              }

              if (parsed.type === "plan_start") {
                setPlanSteps(
                  (parsed.steps as { text: string }[]).map((s) => ({
                    text: s.text,
                    status: "pending" as const,
                  })),
                )
              }

              if (parsed.type === "plan_step_update") {
                setPlanSteps((prev) => {
                  const updated = [...prev]
                  const idx = parsed.stepIndex as number
                  if (idx >= 0 && idx < updated.length) {
                    updated[idx] = {
                      ...updated[idx],
                      status: parsed.status as PlanStep["status"],
                    }
                  }
                  return updated
                })
              }

              if (parsed.type === "session_meta") {
                // Update session title in real-time and refresh sessions list
                if (parsed.title) {
                  queryClient.invalidateQueries({ queryKey: ["chat-sessions"] })
                }
              }

              if (parsed.type === "error") {
                setMessages((prev) => {
                  const updated = [...prev]
                  const last = updated[updated.length - 1]
                  if (last && last.role === "assistant") {
                    updated[updated.length - 1] = {
                      ...last,
                      content: `Error: ${parsed.error}`,
                    }
                  }
                  return updated
                })
              }

              // Legacy format support
              if (!parsed.type && parsed.content) {
                setMessages((prev) => {
                  const updated = [...prev]
                  const last = updated[updated.length - 1]
                  if (last && last.role === "assistant") {
                    updated[updated.length - 1] = {
                      ...last,
                      content: last.content + parsed.content,
                    }
                  }
                  return updated
                })
              }

              if (!parsed.type && parsed.toolCall) {
                const tc = parsed.toolCall as { name: string; status: string }
                if (tc.status === "executing") {
                  setToolCalls((prev) => {
                    const next = new Map(prev)
                    next.set(tc.name, {
                      name: tc.name,
                      label: `Running ${tc.name}...`,
                      input: {},
                      status: "executing",
                    })
                    return next
                  })
                } else {
                  setToolCalls((prev) => {
                    const next = new Map(prev)
                    const existing = next.get(tc.name)
                    if (existing) {
                      next.set(tc.name, { ...existing, status: "complete" })
                    }
                    return next
                  })
                }
              }
            } catch {
              // Skip non-JSON
            }
          }
        }
      } catch (error) {
        if ((error as Error).name === "AbortError") {
          // User stopped generation — keep partial content
          return
        }
        setMessages((prev) => {
          const updated = [...prev]
          const last = updated[updated.length - 1]
          if (last && last.role === "assistant" && !last.content) {
            updated[updated.length - 1] = {
              ...last,
              content: "Sorry, I encountered an error. Please try again.",
            }
          }
          return updated
        })
      } finally {
        setIsStreaming(false)
        abortRef.current = null
        // Now that streaming is done, notify the provider of the new session ID
        // so the sidebar session list highlights the correct session
        if (deferredSessionIdRef.current) {
          switchSession(deferredSessionIdRef.current)
          deferredSessionIdRef.current = null
        }
        // Refresh sessions list
        queryClient.invalidateQueries({ queryKey: ["chat-sessions"] })
      }
    },
    [
      isStreaming,
      currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  /**
   * Send an auto-analyze message. Does NOT add a visible user message.
   * Creates an assistant message with autoGenerated metadata.
   */
  const sendAutoAnalyze = useCallback(
    async (prompt: string, turn: number, depth: AutoAnalyzeDepth) => {
      if (isStreaming) return

      setIsStreaming(true)
      setToolCalls(new Map())

      const assistantMsg: ChatMessage = {
        id: `auto-${turn}-${Date.now()}`,
        role: "assistant",
        content: "",
        metadata: { autoGenerated: true, turn, depth },
      }
      setMessages((prev) => [...prev, assistantMsg])

      const controller = new AbortController()
      abortRef.current = controller

      try {
        const isNewSession = !currentSessionId
        const contextPayload =
          isNewSession && pendingContext
            ? {
                contextMode: pendingContext.contextMode,
                contextData: pendingContext.contextData,
              }
            : {}

        const res = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            sessionId: currentSessionId,
            message: prompt,
            teamId: pageContext.teamId,
            formatId: pageContext.formatId,
            context: {
              pageType: pageContext.pageType,
              contextSummary: pageContext.contextSummary,
              teamId: pageContext.teamId,
              pokemonId: pageContext.pokemonId,
              formatId: pageContext.formatId,
            },
            ...contextPayload,
            autoAnalyzeDepth: depth,
            metadata: { autoGenerated: true, turn, depth },
          }),
          signal: controller.signal,
        })

        const newSessionId = res.headers.get("X-Session-Id")
        if (newSessionId && !currentSessionId) {
          setCurrentSessionId(newSessionId)
          currentSessionIdRef.current = newSessionId
          deferredSessionIdRef.current = newSessionId
          if (pendingContext) clearPendingContext()
        }

        if (!res.ok || !res.body) {
          throw new Error("Failed to get response")
        }

        const reader = res.body.getReader()
        const decoder = new TextDecoder()
        let buffer = ""

        while (true) {
          const { done, value } = await reader.read()
          if (done) break

          buffer += decoder.decode(value, { stream: true })
          const lines = buffer.split("\n")
          buffer = lines.pop() ?? ""

          for (const line of lines) {
            if (!line.startsWith("data: ")) continue
            const data = line.slice(6)

            try {
              const parsed = JSON.parse(data)

              if (parsed.type === "content") {
                setMessages((prev) => {
                  const updated = [...prev]
                  const last = updated[updated.length - 1]
                  if (last && last.role === "assistant") {
                    updated[updated.length - 1] = {
                      ...last,
                      content: last.content + parsed.content,
                    }
                  }
                  return updated
                })
              }

              if (parsed.type === "tool_start") {
                setToolCalls((prev) => {
                  const next = new Map(prev)
                  next.set(parsed.name, {
                    name: parsed.name,
                    label: parsed.label,
                    input: parsed.input,
                    status: "executing",
                  })
                  return next
                })
              }

              if (parsed.type === "tool_end") {
                setToolCalls((prev) => {
                  const next = new Map(prev)
                  const existing = next.get(parsed.name)
                  if (existing) {
                    next.set(parsed.name, { ...existing, status: "complete" })
                  }
                  return next
                })
              }

              // Legacy format
              if (!parsed.type && parsed.content) {
                setMessages((prev) => {
                  const updated = [...prev]
                  const last = updated[updated.length - 1]
                  if (last && last.role === "assistant") {
                    updated[updated.length - 1] = {
                      ...last,
                      content: last.content + parsed.content,
                    }
                  }
                  return updated
                })
              }
            } catch {
              // Skip non-JSON
            }
          }
        }
      } catch (error) {
        if ((error as Error).name === "AbortError") {
          // User made a move — set a dismissive message
          setMessages((prev) => {
            const updated = [...prev]
            const last = updated[updated.length - 1]
            if (last && last.role === "assistant" && last.metadata?.autoGenerated) {
              updated[updated.length - 1] = {
                ...last,
                content: last.content || "You chose your move -- moving on!",
              }
            }
            return updated
          })
          return
        }
        setMessages((prev) => {
          const updated = [...prev]
          const last = updated[updated.length - 1]
          if (last && last.role === "assistant" && !last.content) {
            updated[updated.length - 1] = {
              ...last,
              content: "Analysis failed. Will retry next turn.",
            }
          }
          return updated
        })
      } finally {
        setIsStreaming(false)
        abortRef.current = null
        if (deferredSessionIdRef.current) {
          switchSession(deferredSessionIdRef.current)
          deferredSessionIdRef.current = null
        }
        queryClient.invalidateQueries({ queryKey: ["chat-sessions"] })
      }
    },
    [
      isStreaming,
      currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  // Register stream controls with ChatProvider
  useEffect(() => {
    registerStreamControl({
      sendAutoAnalyze,
      stopGeneration: () => abortRef.current?.abort(),
      isStreaming,
    })
  }, [registerStreamControl, sendAutoAnalyze, isStreaming])

  const stopGeneration = useCallback(() => {
    abortRef.current?.abort()
  }, [])

  const retryLast = useCallback(() => {
    // Find the last user message and regenerate
    const lastUser = [...messages].reverse().find((m) => m.role === "user")
    if (!lastUser) return
    // Remove the last assistant message from UI
    setMessages((prev) => {
      const idx = prev.findLastIndex((m) => m.role === "assistant")
      if (idx >= 0) {
        return [...prev.slice(0, idx), ...prev.slice(idx + 1)]
      }
      return prev
    })
    sendMessage(lastUser.content, true)
  }, [messages, sendMessage])

  const resetForSession = useCallback(
    (id: string | null) => {
      // Skip reset if the hook already owns this session (e.g., after streaming
      // created it) — avoids clearing messages that were built during streaming
      if (id && id === currentSessionIdRef.current) return

      setMessages([])
      setToolCalls(new Map())
      setActionNotifications([])
      setPlanSteps([])
      setCurrentSessionId(id ?? undefined)
      currentSessionIdRef.current = id ?? undefined
      if (id) {
        loadSession(id)
      }
    },
    [loadSession],
  )

  return {
    messages,
    isStreaming,
    toolCalls,
    actionNotifications,
    planSteps,
    currentSessionId,
    sendMessage,
    sendAutoAnalyze,
    stopGeneration,
    retryLast,
    resetForSession,
  }
}
