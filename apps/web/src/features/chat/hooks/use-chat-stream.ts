"use client"

import { useCallback, useEffect } from "react"
import { useChatSidebar } from "@/features/chat/context/ChatProvider"
import type { AutoAnalyzeDepth } from "@nasty-plot/core"
import { useChatMessages } from "./use-chat-messages"
import { useStreamConnection } from "./use-stream-connection"
import type { ChatStreamOptions } from "./types"

// Re-export all types so existing consumers keep working
export type {
  UIChatMessage,
  ToolCallState,
  ActionNotification,
  PlanStep,
  ChatStreamOptions,
} from "./types"

export function useChatStream(sessionId?: string, options?: ChatStreamOptions) {
  const chatMessages = useChatMessages(sessionId)
  const {
    messages,
    setMessages,
    isStreaming,
    toolCalls,
    actionNotifications,
    planSteps,
    queuedMessage,
    queuedMessageRef,
    setQueuedMessage,
    beginStream,
    clearQueuedMessage,
    updateQueuedMessage,
    resetForSession,
  } = chatMessages

  const { registerStreamControl } = useChatSidebar()

  const {
    executeStream,
    buildRequestBody,
    abort,
    setSendMessageRef,
    pageContext,
    pendingContext,
    clearPendingContext,
    switchSession,
    queryClient,
  } = useStreamConnection(chatMessages, options)

  const sendMessage = useCallback(
    async (
      text: string,
      regenerate = false,
      extraContext?: { guidedBuilder: Record<string, unknown> },
    ) => {
      const trimmed = text.trim()
      if (!trimmed) return

      // Queue the message if currently streaming (don't queue regenerations)
      if (isStreaming && !regenerate) {
        setQueuedMessage(trimmed)
        queuedMessageRef.current = trimmed
        return
      }

      if (!regenerate) {
        setMessages((prev) => [
          ...prev,
          { id: `user-${Date.now()}`, role: "user" as const, content: trimmed },
        ])
      }

      beginStream({ id: `assistant-${Date.now()}`, role: "assistant", content: "" })

      const requestBody = buildRequestBody(trimmed)
      const context = extraContext?.guidedBuilder
        ? { ...requestBody.context, guidedBuilder: extraContext.guidedBuilder }
        : requestBody.context
      await executeStream({ ...requestBody, context, regenerate })
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      isStreaming,
      chatMessages.currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  // Keep sendMessageRef in sync so finalizeStream always calls the latest version
  useEffect(() => {
    setSendMessageRef(sendMessage)
  }, [sendMessage, setSendMessageRef])

  const sendAutoAnalyze = useCallback(
    async (prompt: string, turn: number, depth: AutoAnalyzeDepth) => {
      if (isStreaming) return

      beginStream({
        id: `auto-${turn}-${Date.now()}`,
        role: "assistant",
        content: "",
        metadata: { autoGenerated: true, turn, depth },
      })

      await executeStream(
        {
          ...buildRequestBody(prompt),
          autoAnalyzeDepth: depth,
          metadata: { autoGenerated: true, turn, depth },
        },
        "You chose your move -- moving on!",
        "Analysis failed. Will retry next turn.",
      )
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      isStreaming,
      chatMessages.currentSessionId,
      pageContext,
      switchSession,
      pendingContext,
      clearPendingContext,
      queryClient,
    ],
  )

  // Register stream controls with ChatProvider
  useEffect(() => {
    registerStreamControl({
      sendAutoAnalyze,
      stopGeneration: abort,
      isStreaming,
    })
  }, [registerStreamControl, sendAutoAnalyze, isStreaming, abort])

  const stopGeneration = useCallback(() => {
    abort()
  }, [abort])

  const retryLast = useCallback(() => {
    const lastUserMessage = messages.findLast((m) => m.role === "user")
    if (!lastUserMessage) return
    setMessages((prev) => {
      const idx = prev.findLastIndex((m) => m.role === "assistant")
      return idx >= 0 ? [...prev.slice(0, idx), ...prev.slice(idx + 1)] : prev
    })
    sendMessage(lastUserMessage.content, true)
  }, [messages, sendMessage, setMessages])

  return {
    messages,
    isStreaming,
    toolCalls,
    actionNotifications,
    planSteps,
    currentSessionId: chatMessages.currentSessionId,
    queuedMessage,
    sendMessage,
    sendAutoAnalyze,
    stopGeneration,
    retryLast,
    resetForSession,
    clearQueuedMessage,
    updateQueuedMessage,
  }
}
