import { NextRequest } from "next/server"
import { apiErrorResponse, badRequestResponse, notFoundResponse } from "../../../lib/api-error"
import { readSSEEvents } from "../../../lib/sse"
import {
  streamChat,
  createSession,
  getSession,
  addMessage,
  deleteLastAssistantMessage,
  updateSession,
  type PageContextData,
} from "@nasty-plot/llm"

const MAX_TITLE_LENGTH = 50
const MIN_WORD_BREAK_POS = 20
const MAX_SENTENCE_LENGTH = 60

export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    const {
      sessionId,
      message,
      teamId,
      formatId,
      context,
      contextMode,
      contextData,
      regenerate,
      autoAnalyzeDepth,
      metadata,
    }: {
      sessionId?: string
      message: string
      teamId?: string
      formatId?: string
      autoAnalyzeDepth?: "quick" | "deep"
      metadata?: { autoGenerated?: boolean; turn?: number; depth?: "quick" | "deep" }
      context?: PageContextData
      contextMode?: string
      contextData?: string
      regenerate?: boolean
    } = body

    if (!message || typeof message !== "string") {
      return badRequestResponse("message is required", "INVALID_INPUT")
    }

    let currentSessionId = sessionId
    if (currentSessionId) {
      const existing = await getSession(currentSessionId)
      if (!existing) {
        return notFoundResponse("Session")
      }
    } else {
      const createTeamId = teamId || tryParseJson(contextData)?.teamId
      const session = await createSession({
        teamId: createTeamId,
        contextMode: contextMode ?? undefined,
        contextData: contextData ?? undefined,
      })
      currentSessionId = session.id
    }

    if (regenerate) {
      await deleteLastAssistantMessage(currentSessionId)
    } else {
      await addMessage(currentSessionId, { role: "user", content: message, metadata })
    }

    const session = await getSession(currentSessionId)
    const messages = session?.messages ?? [{ role: "user" as const, content: message }]

    const sessionContextMode = session?.contextMode ?? contextMode
    const sessionContextData = session?.contextData ?? contextData

    const { effectiveTeamId, effectiveFormatId } = resolveContextIds({
      sessionContextMode,
      sessionContextData,
      teamId,
      formatId,
      pageTeamId: context?.teamId,
      pageFormatId: context?.formatId,
    })

    const stream = await streamChat({
      messages,
      teamId: effectiveTeamId,
      formatId: effectiveFormatId,
      signal: req.signal,
      context,
      contextMode: sessionContextMode,
      contextData: sessionContextData,
      disableAllTools: autoAnalyzeDepth === "quick",
    })

    const [streamForClient, streamForSave] = stream.tee()

    const assistantMetadata = metadata?.autoGenerated ? metadata : undefined
    collectAndSave(streamForSave, currentSessionId, assistantMetadata).catch(console.error)

    if (!sessionId && !regenerate) {
      generateTitleInBackground(currentSessionId, message).catch(console.error)
    }

    return new Response(streamForClient, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "X-Session-Id": currentSessionId,
      },
    })
  } catch (error) {
    return apiErrorResponse(error, { fallback: "Internal server error", code: "INTERNAL_ERROR" })
  }
}

async function collectAndSave(
  stream: ReadableStream<Uint8Array>,
  sessionId: string,
  metadata?: { autoGenerated?: boolean; turn?: number; depth?: "quick" | "deep" },
) {
  let fullContent = ""

  try {
    for await (const event of readSSEEvents<{ type?: string; content?: string }>(stream)) {
      const isContentEvent = event.type === "content" || !event.type
      if (isContentEvent && event.content) fullContent += event.content
    }

    if (fullContent) {
      await addMessage(sessionId, { role: "assistant", content: fullContent, metadata })
    }
  } catch (error) {
    console.error("Error saving assistant message:", error)
  }
}

function tryParseJson(json: string | undefined): Record<string, string> | null {
  if (!json) return null
  try {
    return JSON.parse(json)
  } catch {
    return null
  }
}

function resolveContextIds(params: {
  sessionContextMode: string | undefined
  sessionContextData: string | undefined
  teamId: string | undefined
  formatId: string | undefined
  pageTeamId: string | undefined
  pageFormatId: string | undefined
}): { effectiveTeamId: string | undefined; effectiveFormatId: string | undefined } {
  const { sessionContextMode, sessionContextData, teamId, formatId, pageTeamId, pageFormatId } =
    params
  const liveTeamId = teamId || pageTeamId
  const liveFormatId = formatId || pageFormatId
  const stored = tryParseJson(sessionContextData)

  if (sessionContextMode && sessionContextData) {
    return {
      effectiveTeamId: stored?.teamId || liveTeamId,
      effectiveFormatId: stored?.formatId || liveFormatId,
    }
  }

  return {
    effectiveTeamId: liveTeamId || stored?.teamId,
    effectiveFormatId: liveFormatId || stored?.formatId,
  }
}

async function generateTitleInBackground(sessionId: string, firstMessage: string) {
  try {
    const stripped = firstMessage
      .replace(/[#*_`~\[\]()>]/g, "")
      .replace(/\s+/g, " ")
      .trim()

    const title = truncateToTitle(stripped)
    await updateSession(sessionId, { title })
  } catch (error) {
    console.error("Error generating title:", error)
  }
}

function truncateToTitle(text: string): string {
  const sentenceEnd = text.search(/[.!?]/)
  if (sentenceEnd > 0 && sentenceEnd <= MAX_SENTENCE_LENGTH) {
    return text.slice(0, sentenceEnd + 1)
  }

  if (text.length <= MAX_TITLE_LENGTH) return text

  const truncated = text.slice(0, MAX_TITLE_LENGTH)
  const lastSpace = truncated.lastIndexOf(" ")
  return (lastSpace > MIN_WORD_BREAK_POS ? truncated.slice(0, lastSpace) : truncated) + "..."
}
