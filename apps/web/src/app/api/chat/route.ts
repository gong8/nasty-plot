import { NextRequest } from "next/server"
import { apiErrorResponse } from "../../../lib/api-error"
import {
  streamChat,
  createSession,
  getSession,
  addMessage,
  deleteLastAssistantMessage,
  updateSession,
  type PageContextData,
} from "@nasty-plot/llm"

export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    const {
      sessionId,
      message,
      teamId,
      formatId,
      context,
      contextMode,
      contextData,
      regenerate,
      autoAnalyzeDepth,
      metadata,
    }: {
      sessionId?: string
      message: string
      teamId?: string
      formatId?: string
      autoAnalyzeDepth?: "quick" | "deep"
      metadata?: { autoGenerated?: boolean; turn?: number; depth?: "quick" | "deep" }
      context?: PageContextData
      contextMode?: string
      contextData?: string
      regenerate?: boolean
    } = body

    if (!message || typeof message !== "string") {
      return Response.json({ error: "message is required", code: "INVALID_INPUT" }, { status: 400 })
    }

    // Get or create session
    let currentSessionId = sessionId
    if (currentSessionId) {
      const existing = await getSession(currentSessionId)
      if (!existing) {
        return Response.json({ error: "Session not found", code: "NOT_FOUND" }, { status: 404 })
      }
    } else {
      // Extract teamId from contextData as fallback for session-team linking
      const createTeamId = teamId || tryParseJson(contextData)?.teamId
      const session = await createSession({
        teamId: createTeamId,
        contextMode: contextMode ?? undefined,
        contextData: contextData ?? undefined,
      })
      currentSessionId = session.id
    }

    // Handle regenerate: remove last assistant message
    if (regenerate) {
      await deleteLastAssistantMessage(currentSessionId)
    } else {
      // Save user message
      await addMessage(currentSessionId, { role: "user", content: message, metadata })
    }

    // Build message history
    const session = await getSession(currentSessionId)
    const messages = session?.messages ?? [{ role: "user" as const, content: message }]

    // Use abort signal from request for stop generation
    const signal = req.signal

    // Use session's context mode (persisted) â€” it overrides page-based filtering
    const sessionContextMode = session?.contextMode ?? contextMode
    const sessionContextData = session?.contextData ?? contextData

    // Extract teamId/formatId from context hierarchy
    const { effectiveTeamId, effectiveFormatId } = resolveContextIds({
      sessionContextMode,
      sessionContextData,
      teamId,
      formatId,
      pageTeamId: context?.teamId,
      pageFormatId: context?.formatId,
    })

    // Stream response
    const stream = await streamChat({
      messages,
      teamId: effectiveTeamId,
      formatId: effectiveFormatId,
      signal,
      context,
      contextMode: sessionContextMode,
      contextData: sessionContextData,
      disableAllTools: autoAnalyzeDepth === "quick",
    })

    // Collect the full response for saving
    const [streamForClient, streamForSave] = stream.tee()

    // Save assistant response in the background
    const assistantMetadata = metadata?.autoGenerated ? metadata : undefined
    collectAndSave(streamForSave, currentSessionId, assistantMetadata).catch(console.error)

    // Fire-and-forget title generation after first exchange
    if (!sessionId && !regenerate) {
      generateTitleInBackground(currentSessionId, message).catch(console.error)
    }

    return new Response(streamForClient, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "X-Session-Id": currentSessionId,
      },
    })
  } catch (error) {
    console.error("Chat API error:", error)
    return apiErrorResponse(error, { fallback: "Internal server error", code: "INTERNAL_ERROR" })
  }
}

async function collectAndSave(
  stream: ReadableStream<Uint8Array>,
  sessionId: string,
  metadata?: { autoGenerated?: boolean; turn?: number; depth?: "quick" | "deep" },
) {
  const decoder = new TextDecoder()
  const reader = stream.getReader()
  let fullContent = ""

  try {
    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const text = decoder.decode(value, { stream: true })
      const lines = text.split("\n")

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue
        const data = line.slice(6)

        try {
          const parsed = JSON.parse(data)
          const isContentEvent = parsed.type === "content" || !parsed.type
          if (isContentEvent && parsed.content) {
            fullContent += parsed.content
          }
        } catch {
          // Skip non-JSON lines
        }
      }
    }

    if (fullContent) {
      await addMessage(sessionId, {
        role: "assistant",
        content: fullContent,
        metadata,
      })
    }
  } catch (error) {
    console.error("Error saving assistant message:", error)
  }
}

function tryParseJson(json: string | undefined): Record<string, string> | null {
  if (!json) return null
  try {
    return JSON.parse(json)
  } catch {
    return null
  }
}

function resolveContextIds(params: {
  sessionContextMode: string | undefined
  sessionContextData: string | undefined
  teamId: string | undefined
  formatId: string | undefined
  pageTeamId: string | undefined
  pageFormatId: string | undefined
}): { effectiveTeamId: string | undefined; effectiveFormatId: string | undefined } {
  const { sessionContextMode, sessionContextData, teamId, formatId, pageTeamId, pageFormatId } =
    params
  const liveTeamId = teamId || pageTeamId
  const liveFormatId = formatId || pageFormatId
  const stored = tryParseJson(sessionContextData)

  if (sessionContextMode && sessionContextData) {
    // Context-locked session: frozen context takes priority over live
    return {
      effectiveTeamId: stored?.teamId || liveTeamId,
      effectiveFormatId: stored?.formatId || liveFormatId,
    }
  }

  // General session: live context takes priority, fall back to stored
  return {
    effectiveTeamId: liveTeamId || stored?.teamId,
    effectiveFormatId: liveFormatId || stored?.formatId,
  }
}

async function generateTitleInBackground(sessionId: string, firstMessage: string) {
  try {
    // Generate a concise title from the first message.
    // Strip markdown, take first sentence or meaningful fragment (max ~60 chars).
    let title = firstMessage
      .replace(/[#*_`~\[\]()>]/g, "") // strip markdown
      .replace(/\s+/g, " ") // collapse whitespace
      .trim()

    // Try to use the first sentence
    const sentenceEnd = title.search(/[.!?]/)
    if (sentenceEnd > 0 && sentenceEnd <= 60) {
      title = title.slice(0, sentenceEnd + 1)
    } else if (title.length > 50) {
      // Break at word boundary
      const truncated = title.slice(0, 50)
      const lastSpace = truncated.lastIndexOf(" ")
      title = (lastSpace > 20 ? truncated.slice(0, lastSpace) : truncated) + "..."
    }

    await updateSession(sessionId, { title })
  } catch (error) {
    console.error("Error generating title:", error)
  }
}
